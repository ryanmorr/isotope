/*! @ryanmorr/isotope v3.2.1 | https://github.com/ryanmorr/isotope */
class s{#s;#e=[];constructor(s){this.#s=s,this.#e=[]}value(){return this.#s}set(s){const e=this.value();if(s!==e)return this.#s=s,this.#e.slice().forEach((t=>t(s,e))),s}subscribe(s){const e=this.#e;if(!e.includes(s))return e.push(s),s(this.value()),()=>{const t=e.indexOf(s);-1!==t&&e.splice(t,1)}}then(s){s(this.value())}toString(){return String(this.value())}valueOf(){return this.value()}toJSON(){return this.value()}}class e extends s{update(s){return this.set(s(this.value()))}}class t extends s{#t;constructor(s,e){super(s),this.#t=e}dispatch(s){return super.set(this.#t(this.value(),s))}}class r extends s{constructor(s,e,t){super();let r=!1;const u=[],n=t?()=>super.set(e(u)):()=>super.set(e(...u));s.forEach(((s,e)=>s.subscribe((s=>{u[e]=s,r&&n()})))),r=!0,n()}}class u extends s{constructor(s,e,t){super();let r=0,u=!1;const n=[],c=t?s=>e(n,s):s=>e(...n.concat([s]));s.forEach(((s,e)=>s.subscribe((s=>{if(n[e]=s,u){r++;const s=r;c((e=>{r===s&&super.set(e)}))}})))),u=!0,c((s=>super.set(s)))}}function n(s){return new e(s)}function c(s,e){return new t(s,e)}function i(...s){let e,t;const n=Array.isArray(s[0]);n?(e=s[0],t=s[1]):(e=s,t=s.pop());const c=t.length;return n&&2===c||c>e.length?new u(e,t,n):new r(e,t,n)}r.prototype.set=void 0,u.prototype.set=void 0,t.prototype.set=void 0;export{s as Store,i as derived,c as reducer,n as store};
