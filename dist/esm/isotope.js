/*! @ryanmorr/isotope v3.1.0 | https://github.com/ryanmorr/isotope */
class s{constructor(s){this._value=s,this._subscribers=[]}value(){return this._value}set(s){const t=this.value();if(s!==t)return this._value=s,this._subscribers.slice().forEach((e=>e(s,t))),s}subscribe(s){const t=this._subscribers;if(!t.includes(s))return t.push(s),s(this.value()),()=>{const e=t.indexOf(s);-1!==e&&t.splice(e,1)}}then(s){s(this.value())}toString(){return String(this.value())}valueOf(){return this.value()}toJSON(){return this.value()}}class t extends s{update(s){return this.set(s(this.value()))}}class e extends s{constructor(s,t){super(s),this._reducer=t}dispatch(s){return super.set(this._reducer(this.value(),s))}}class r extends s{constructor(s,t){super();let e=!1;const r=[],u=()=>super.set(t(...r));s.forEach(((s,t)=>s.subscribe((s=>{r[t]=s,e&&u()})))),e=!0,u()}}class u extends s{constructor(s,t){super();let e=0,r=!1;const u=[],n=s=>t(...u.concat([s]));s.forEach(((s,t)=>s.subscribe((s=>{if(u[t]=s,r){e++;const s=e;n((t=>{e===s&&super.set(t)}))}})))),r=!0,n((s=>super.set(s)))}}function n(s){return new t(s)}function c(s,t){return new e(s,t)}function i(...s){const t=s.pop();return t.length>s.length?new u(s,t):new r(s,t)}r.prototype.set=void 0,u.prototype.set=void 0,e.prototype.set=void 0;export{s as Store,i as derived,c as reducer,n as store};
