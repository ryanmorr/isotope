/*! @ryanmorr/isotope v3.2.0 | https://github.com/ryanmorr/isotope */
"use strict";class e{constructor(e){this._value=e,this._subscribers=[]}value(){return this._value}set(e){const s=this.value();if(e!==s)return this._value=e,this._subscribers.slice().forEach((t=>t(e,s))),e}subscribe(e){const s=this._subscribers;if(!s.includes(e))return s.push(e),e(this.value()),()=>{const t=s.indexOf(e);-1!==t&&s.splice(t,1)}}then(e){e(this.value())}toString(){return String(this.value())}valueOf(){return this.value()}toJSON(){return this.value()}}class s extends e{update(e){return this.set(e(this.value()))}}class t extends e{constructor(e,s){super(e),this._reducer=s}dispatch(e){return super.set(this._reducer(this.value(),e))}}class r extends e{constructor(e,s){super();let t=!1;const r=[],u=()=>super.set(s(...r));e.forEach(((e,s)=>e.subscribe((e=>{r[s]=e,t&&u()})))),t=!0,u()}}class u extends e{constructor(e,s){super();let t=0,r=!1;const u=[],n=e=>s(...u.concat([e]));e.forEach(((e,s)=>e.subscribe((e=>{if(u[s]=e,r){t++;const e=t;n((s=>{t===e&&super.set(s)}))}})))),r=!0,n((e=>super.set(e)))}}r.prototype.set=void 0,u.prototype.set=void 0,t.prototype.set=void 0,exports.Store=e,exports.derived=function(...e){let s,t;return Array.isArray(e[0])?(s=e[0],t=e[1]):(s=e,t=e.pop()),t.length>s.length?new u(s,t):new r(s,t)},exports.reducer=function(e,s){return new t(e,s)},exports.store=function(e){return new s(e)};
