/*! @ryanmorr/isotope v3.2.1 | https://github.com/ryanmorr/isotope */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).isotope={})}(this,(function(e){"use strict";class t{#e;#t=[];constructor(e){this.#e=e,this.#t=[]}value(){return this.#e}set(e){const t=this.value();if(e!==t)return this.#e=e,this.#t.slice().forEach((s=>s(e,t))),e}subscribe(e){const t=this.#t;if(!t.includes(e))return t.push(e),e(this.value()),()=>{const s=t.indexOf(e);-1!==s&&t.splice(s,1)}}then(e){e(this.value())}toString(){return String(this.value())}valueOf(){return this.value()}toJSON(){return this.value()}}class s extends t{update(e){return this.set(e(this.value()))}}class r extends t{#s;constructor(e,t){super(e),this.#s=t}dispatch(e){return super.set(this.#s(this.value(),e))}}class u extends t{constructor(e,t,s){super();let r=!1;const u=[],n=s?()=>super.set(t(u)):()=>super.set(t(...u));e.forEach(((e,t)=>e.subscribe((e=>{u[t]=e,r&&n()})))),r=!0,n()}}class n extends t{constructor(e,t,s){super();let r=0,u=!1;const n=[],i=s?e=>t(n,e):e=>t(...n.concat([e]));e.forEach(((e,t)=>e.subscribe((e=>{if(n[t]=e,u){r++;const e=r;i((t=>{r===e&&super.set(t)}))}})))),u=!0,i((e=>super.set(e)))}}u.prototype.set=void 0,n.prototype.set=void 0,r.prototype.set=void 0,e.Store=t,e.derived=function(...e){let t,s;const r=Array.isArray(e[0]);r?(t=e[0],s=e[1]):(t=e,s=e.pop());const i=s.length;return r&&2===i||i>t.length?new n(t,s,r):new u(t,s,r)},e.reducer=function(e,t){return new r(e,t)},e.store=function(e){return new s(e)}}));
