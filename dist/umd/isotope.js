/*! @ryanmorr/isotope v3.1.0 | https://github.com/ryanmorr/isotope */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).isotope={})}(this,(function(e){"use strict";class t{constructor(e){this._value=e,this._subscribers=[]}value(){return this._value}set(e){const t=this.value();if(e!==t)return this._value=e,this._subscribers.slice().forEach((s=>s(e,t))),e}subscribe(e){const t=this._subscribers;if(!t.includes(e))return t.push(e),e(this.value()),()=>{const s=t.indexOf(e);-1!==s&&t.splice(s,1)}}then(e){e(this.value())}toString(){return String(this.value())}valueOf(){return this.value()}toJSON(){return this.value()}}class s extends t{update(e){return this.set(e(this.value()))}}class r extends t{constructor(e,t){super(e),this._reducer=t}dispatch(e){return super.set(this._reducer(this.value(),e))}}class n extends t{constructor(e,t){super();let s=!1;const r=[],n=()=>super.set(t(...r));e.forEach(((e,t)=>e.subscribe((e=>{r[t]=e,s&&n()})))),s=!0,n()}}class u extends t{constructor(e,t){super();let s=0,r=!1;const n=[],u=e=>t(...n.concat([e]));e.forEach(((e,t)=>e.subscribe((e=>{if(n[t]=e,r){s++;const e=s;u((t=>{s===e&&super.set(t)}))}})))),r=!0,u((e=>super.set(e)))}}n.prototype.set=void 0,u.prototype.set=void 0,r.prototype.set=void 0,e.Store=t,e.derived=function(...e){const t=e.pop();return t.length>e.length?new u(e,t):new n(e,t)},e.reducer=function(e,t){return new r(e,t)},e.store=function(e){return new s(e)}}));
